<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Football Live Streams</title>
<style>
  body {
    margin: 0;
    font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
    background: linear-gradient(180deg, #0f0f0f, #1a1a1a);
    color: #e0e0e0;
    display: flex;
    flex-direction: column;
    min-height: 100vh;
    overflow-x: hidden;
  }
  header {
    padding: 20px 40px;
    background: linear-gradient(90deg, #1a1a1a, #2a2a2a);
    display: flex;
    justify-content: space-between;
    align-items: center;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
    position: sticky;
    top: 0;
    z-index: 1500;
  }
  header h1 {
    margin: 0;
    font-size: 2rem;
    font-weight: 700;
    color: #ff9900;
    text-shadow: 0 1px 3px rgba(255, 153, 0, 0.3);
  }
  .nav-tabs {
    display: flex;
    gap: 20px;
  }
  .nav-tab {
    padding: 10px 20px;
    border-radius: 10px;
    cursor: pointer;
    background: #333333;
    transition: all 0.3s ease;
    font-weight: 600;
    font-size: 1.1rem;
    color: #cccccc;
  }
  .nav-tab:hover {
    background: #444444;
    transform: scale(1.05);
  }
  .nav-tab.active {
    background: #ff9900;
    color: #fff;
    transform: scale(1.1);
    box-shadow: 0 2px 6px rgba(255, 153, 0, 0.4);
  }
  #statusBar {
    padding: 12px 40px;
    background: #222222;
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 1rem;
    border-bottom: 2px solid #3a3a3a;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
  }
  #statusBar .warning {
    color: #ffcc33;
    font-weight: 600;
  }
  #statusBar .status-loading { color: #00ccff; }
  #statusBar .status-active { color: #00ff66; }
  #statusBar .status-frozen { color: #ff6666; }
  #statusBar .status-not-playing { color: #ffcc33; }
  #timer {
    font-weight: 700;
    font-size: 1.2rem;
    color: #e0e0e0;
    text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
  }
  .page {
    display: none;
    flex: 1;
    overflow-y: auto;
    animation: fadeIn 0.4s ease;
  }
  .page.active {
    display: flex;
    flex-direction: column;
  }
  @keyframes fadeIn {
    from { opacity: 0; transform: translateY(15px); }
    to { opacity: 1; transform: translateY(0); }
  }
  #schedule.active, #streams.active {
    padding: 30px 40px;
  }
  #match.active {
    padding: 0;
    height: 100vh;
  }
  #playerContainer {
    position: relative;
    width: 100%;
    height: 100%;
    display: flex;
    flex: 1;
  }
  #playerContainer::after {
    content: '';
    position: absolute;
    top: 10px;
    left: 10px;
    right: 10px;
    bottom: 10px;
    border: 2px solid rgba(255, 153, 0, 0.3);
    border-radius: 10px;
    pointer-events: none;
    z-index: 1;
  }
  iframe {
    width: 100%;
    height: 100%;
    border: none;
    position: absolute;
    top: 0;
    left: 0;
    z-index: 0;
  }
  .schedule-grid {
    display: grid;
    gap: 25px;
    grid-template-columns: repeat(auto-fill, minmax(400px, 1fr));
    padding: 25px 0;
  }
  .schedule-item {
    background: linear-gradient(135deg, #252525, #333333);
    padding: 25px;
    border-radius: 15px;
    cursor: pointer;
    transition: all 0.4s ease;
    border: 2px solid #444444;
    box-shadow: 0 6px 18px rgba(0, 0, 0, 0.5);
    overflow: hidden;
  }
  .schedule-item:hover {
    transform: translateY(-8px);
    box-shadow: 0 10px 25px rgba(0, 0, 0, 0.6);
    background: linear-gradient(135deg, #2e2e2e, #3c3c3c);
  }
  .match-details {
    display: flex;
    flex-direction: column;
    gap: 10px;
  }
  .match-details h3 {
    margin: 0;
    font-size: 1.5rem;
    color: #ff9900;
    text-shadow: 0 1px 3px rgba(255, 153, 0, 0.3);
    transition: color 0.3s ease;
  }
  .schedule-item:hover h3 {
    color: #ffb366;
  }
  .match-details p {
    margin: 5px 0;
    font-size: 1rem;
    color: #bbbbbb;
    transition: color 0.3s ease;
  }
  .schedule-item:hover p {
    color: #d0d0d0;
  }
  .match-status {
    font-size: 1rem;
    font-weight: 700;
    padding: 6px 15px;
    border-radius: 10px;
    background: #00ff66;
    color: #0a0a0a;
    text-align: center;
    margin-top: 15px;
    display: inline-block;
    transition: background 0.3s ease;
  }
  .match-status.upcoming { background: #ffcc33; }
  .match-status.finished { background: #ff6666; }
  .details-btn {
    margin-top: 15px;
    padding: 10px 20px;
    background: #ff9900;
    border: none;
    border-radius: 8px;
    color: #fff;
    cursor: pointer;
    transition: all 0.3s ease;
    font-weight: 600;
  }
  .details-btn:hover {
    background: #e07b00;
    transform: scale(1.05);
    box-shadow: 0 2px 6px rgba(255, 153, 0, 0.4);
  }
  #scheduleControls {
    display: flex;
    gap: 15px;
    margin-bottom: 25px;
    flex-wrap: wrap;
  }
  .control-btn {
    padding: 10px 20px;
    background: #333333;
    border: none;
    border-radius: 8px;
    color: #e0e0e0;
    cursor: pointer;
    transition: all 0.3s ease;
    font-weight: 600;
  }
  .control-btn:hover {
    background: #444444;
    transform: scale(1.05);
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
  }
  #loadingSpinner {
    display: none;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    border: 10px solid #333333;
    border-top: 10px solid #ff9900;
    border-radius: 50%;
    width: 60px;
    height: 60px;
    animation: spin 1.2s linear infinite;
  }
  @keyframes spin {
    0% { transform: translate(-50%, -50%) rotate(0deg); }
    100% { transform: translate(-50%, -50%) rotate(360deg); }
  }
  .stream-list {
    display: grid;
    gap: 12px;
    grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
    flex: 1;
    margin-top: 20px;
  }
  .stream-item {
    padding: 12px;
    background: linear-gradient(135deg, #2a2a2a, #3a3a3a);
    border-radius: 10px;
    cursor: pointer;
    transition: all 0.3s ease;
    border: 2px solid #444444;
    text-align: center;
    font-weight: 600;
    font-size: 1rem;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
  }
  .stream-item:hover {
    background: linear-gradient(135deg, #333333, #4a4a4a);
    transform: translateY(-5px);
    box-shadow: 0 6px 15px rgba(0, 0, 0, 0.4);
  }
  #streamMatchTitle {
    font-size: 2rem;
    font-weight: 700;
    color: #ff9900;
    margin-bottom: 20px;
    text-align: center;
    text-shadow: 0 1px 3px rgba(255, 153, 0, 0.3);
  }
  @media (max-width: 768px) {
    header {
      padding: 15px 20px;
    }
    .nav-tab {
      font-size: 1rem;
      padding: 8px 15px;
    }
    #statusBar {
      padding: 10px 20px;
    }
    .schedule-grid {
      grid-template-columns: 1fr;
    }
    .stream-list {
      grid-template-columns: 1fr 1fr;
    }
  }
</style>
</head>
<body>
<header>
  <h1>Football Live Streams</h1>
  <div class="nav-tabs" id="navTabs">
    <div class="nav-tab active" data-page="schedule">Schedule</div>
    <div class="nav-tab" data-page="streams">Streams</div>
    <div class="nav-tab" data-page="match">Match</div>
  </div>
</header>
<div id="statusBar">
  <div class="warning" id="streamStatus">⚠️ Stream may experience interruptions</div>
  <div id="timer">Match Timer: 00:00</div>
</div>
<div id="schedule" class="page active">
  <div id="scheduleControls">
    <button class="control-btn" onclick="sortByTime()">Sort by Time</button>
    <button class="control-btn" onclick="filterByStatus('upcoming')">Show Upcoming</button>
    <button class="control-btn" onclick="filterByStatus('live')">Show Live</button>
    <button class="control-btn" onclick="filterByStatus('finished')">Show Finished</button>
  </div>
  <div class="schedule-grid" id="scheduleGrid"></div>
</div>
<div id="streams" class="page">
  <h2 id="streamMatchTitle"></h2>
  <div class="stream-list" id="streamList"></div>
</div>
<div id="match" class="page">
  <div id="playerContainer">
    <iframe id="playerFrame" src="" allowfullscreen allow="encrypted-media; picture-in-picture;"></iframe>
  </div>
</div>
<script>
let matches = [];
let currentMatchIndex = 0;
let currentStreamIndex = 0;
let currentPage = 'schedule';
let timerInterval = null;
let streamLoadTimeout = null;
let streamCheckInterval = null;
let isStreamPlaying = false;
const navTabs = document.getElementById('navTabs');
const scheduleGrid = document.getElementById('scheduleGrid');
const streamMatchTitle = document.getElementById('streamMatchTitle');
const streamList = document.getElementById('streamList');
const playerFrame = document.getElementById('playerFrame');
const streamStatus = document.getElementById('streamStatus');
const timerEl = document.getElementById('timer');
// Page navigation
navTabs.querySelectorAll('.nav-tab').forEach(tab => {
  tab.addEventListener('click', () => {
    currentPage = tab.dataset.page;
    updatePage();
  });
});
function updatePage() {
  document.querySelectorAll('.page').forEach(page => {
    page.classList.toggle('active', page.id === currentPage);
  });
  document.querySelectorAll('.nav-tab').forEach(tab => {
    tab.classList.toggle('active', tab.dataset.page === currentPage);
  });
  if (currentPage === 'schedule') {
    renderSchedule();
    if (timerInterval) clearInterval(timerInterval);
    if (streamCheckInterval) clearInterval(streamCheckInterval);
    if (streamLoadTimeout) clearTimeout(streamLoadTimeout);
    streamStatus.textContent = '⚠️ Stream may experience interruptions';
    streamStatus.className = 'warning';
    isStreamPlaying = false;
  } else if (currentPage === 'streams') {
    renderStreams();
    if (timerInterval) clearInterval(timerInterval);
    if (streamCheckInterval) clearInterval(streamCheckInterval);
    if (streamLoadTimeout) clearTimeout(streamLoadTimeout);
    streamStatus.textContent = '⚠️ Stream may experience interruptions';
    streamStatus.className = 'warning';
    isStreamPlaying = false;
  } else if (currentPage === 'match') {
    loadStream();
    startMatchTimer();
    startStreamCheck();
  }
}
// Fetch matches from API
function fetchMatches() {
  fetch('https://streamed.pk/api/matches/football')
    .then(response => response.json())
    .then(data => {
      matches = data
        .filter(m => m.category === 'football' && m.date > 0) // Filter football and with valid date
        .map(m => ({
          name: m.title,
          startTime: new Date(m.date),
          sources: m.sources,
          poster: m.poster,
          teams: m.teams
        }));
      matches.sort((a, b) => a.startTime - b.startTime);
      renderSchedule();
    })
    .catch(error => console.error('Error fetching matches:', error));
}
// Render schedule page
function renderSchedule() {
  scheduleGrid.innerHTML = '';
  const now = new Date();
  const fourHoursInMs = 4 * 60 * 60 * 1000;
  matches.forEach((match, index) => {
    const elapsed = Math.floor((now - match.startTime) / 1000);
    let status = 'finished';
    let timeText = 'Finished';
    if (elapsed < 0) {
      status = 'upcoming';
      timeText = `Starts in ${formatTime(Math.abs(elapsed))}`;
    } else if (elapsed < 120 * 60) {
      status = 'live';
      timeText = `Live for ${formatTime(elapsed)}`;
    }
    const matchEndTime = new Date(match.startTime.getTime() + 110 * 60 * 1000);
    if (now - matchEndTime <= fourHoursInMs) {
      const item = document.createElement('div');
      item.className = 'schedule-item';
      item.innerHTML = `
        <div class="match-details">
          <h3>${match.name}</h3>
          <p>Status: <span class="match-status ${status}">${status.charAt(0).toUpperCase() + status.slice(1)}</span></p>
          <p>Time: ${timeText}</p>
        </div>
      `;
      item.onclick = () => {
        currentMatchIndex = index;
        currentStreamIndex = 0;
        currentPage = 'streams';
        updatePage();
      };
      scheduleGrid.appendChild(item);
    }
  });
}
function sortByTime() {
  matches.sort((a, b) => a.startTime - b.startTime);
  renderSchedule();
}
function filterByStatus(status) {
  const now = new Date();
  const fourHoursInMs = 4 * 60 * 60 * 1000;
  scheduleGrid.innerHTML = '';
  matches.forEach((match, index) => {
    const elapsed = Math.floor((now - match.startTime) / 1000);
    let matchStatus = 'finished';
    if (elapsed < 0) matchStatus = 'upcoming';
    else if (elapsed < 120 * 60) matchStatus = 'live';
    const matchEndTime = new Date(match.startTime.getTime() + 110 * 60 * 1000);
    if (now - matchEndTime <= fourHoursInMs && (status === 'all' || matchStatus === status)) {
      const item = document.createElement('div');
      item.className = 'schedule-item';
      item.innerHTML = `
        <div class="match-details">
          <h3>${match.name}</h3>
          <p>Status: <span class="match-status ${matchStatus}">${matchStatus.charAt(0).toUpperCase() + matchStatus.slice(1)}</span></p>
          <p>Time: ${elapsed < 0 ? `Starts in ${formatTime(Math.abs(elapsed))}` : `Live for ${formatTime(elapsed)}`}</p>
        </div>
      `;
      item.onclick = () => {
        currentMatchIndex = index;
        currentStreamIndex = 0;
        currentPage = 'streams';
        updatePage();
      };
      scheduleGrid.appendChild(item);
    }
  });
}
function renderStreams() {
  const match = matches[currentMatchIndex];
  streamMatchTitle.textContent = match.name;
  streamList.innerHTML = '<div>Loading streams...</div>'; // Loading indicator
  Promise.all(match.sources.map(source => 
    fetch(`https://streamed.pk/api/stream/${source.source}/${source.id}`)
      .then(res => res.json())
      .then(streamData => streamData.map(s => s.embedUrl))
      .catch(() => []) // Handle errors per source
  ))
  .then(allStreamsArrays => {
    const allUrls = allStreamsArrays.flat().filter(url => url); // Flatten and remove empties
    match.streams = allUrls; // Store in match
    streamList.innerHTML = '';
    allUrls.forEach((url, index) => {
      const item = document.createElement('div');
      item.className = 'stream-item';
      item.textContent = `Stream ${index + 1}`;
      item.onclick = () => {
        currentStreamIndex = index;
        currentPage = 'match';
        updatePage();
      };
      streamList.appendChild(item);
    });
    if (allUrls.length === 0) {
      streamList.innerHTML = '<div>No streams available</div>';
    }
  })
  .catch(error => {
    console.error('Error fetching streams:', error);
    streamList.innerHTML = '<div>Error loading streams</div>';
  });
}
function loadStream() {
  const match = matches[currentMatchIndex];
  if (!match.streams || currentStreamIndex >= match.streams.length) {
    streamStatus.textContent = 'No more streams available';
    streamStatus.className = 'status-frozen';
    return;
  }
  playerFrame.src = match.streams[currentStreamIndex];
  streamStatus.textContent = 'Loading stream...';
  streamStatus.className = 'status-loading';
  isStreamPlaying = false;
  if (streamLoadTimeout) clearTimeout(streamLoadTimeout);
  streamLoadTimeout = setTimeout(() => {
    if (!isStreamPlaying) {
      streamStatus.textContent = 'Stream failed to load, trying another link';
      streamStatus.className = 'status-frozen';
      currentStreamIndex = (currentStreamIndex + 1) % match.streams.length;
      loadStream();
    }
  }, 5000);
  playerFrame.onload = () => {
    isStreamPlaying = true;
    streamStatus.textContent = 'Stream active';
    streamStatus.className = 'status-active';
    if (streamLoadTimeout) clearTimeout(streamLoadTimeout);
  };
  playerFrame.onerror = () => {
    isStreamPlaying = false;
    streamStatus.textContent = 'Stream failed to load, trying another link';
    streamStatus.className = 'status-frozen';
    currentStreamIndex = (currentStreamIndex + 1) % match.streams.length;
    loadStream();
  };
}
function startStreamCheck() {
  if (streamCheckInterval) clearInterval(streamCheckInterval);
  streamCheckInterval = setInterval(() => {
    if (currentPage !== 'match') return;
    if (isStreamPlaying) {
      streamStatus.textContent = 'Stream active';
      streamStatus.className = 'status-active';
    } else {
      streamStatus.textContent = 'Stream not playing';
      streamStatus.className = 'status-not-playing';
    }
  }, 2000);
}
function startMatchTimer() {
  if (timerInterval) clearInterval(timerInterval);
  const match = matches[currentMatchIndex];
  const startTime = match.startTime;
  timerInterval = setInterval(() => {
    const currentTime = new Date();
    let elapsed = Math.floor((currentTime - startTime) / 1000);
    let displayText = "";
    if (elapsed < 0) {
      displayText = `Match Starts In: ${formatTime(Math.abs(elapsed))}`;
    } else if (elapsed < 45 * 60) {
      displayText = `Match Timer: ${formatTime(elapsed)} (1st Half)`;
    } else if (elapsed < 50 * 60) {
      displayText = `Match Timer: ${formatTime(elapsed - 45 * 60)} (1st Half Added Time)`;
    } else if (elapsed < 60 * 60) {
      displayText = `Halftime: ${formatTime(elapsed - 50 * 60)}`;
    } else if (elapsed < 105 * 60) {
      displayText = `Match Timer: ${formatTime(elapsed - 60 * 60 + 45 * 60)} (2nd Half)`;
    } else if (elapsed < 110 * 60) {
      displayText = `Match Timer: ${formatTime(elapsed - 105 * 60)} (2nd Half Added Time)`;
    } else {
      displayText = "Full Time";
      clearInterval(timerInterval);
    }
    timerEl.textContent = displayText;
  }, 1000);
}
function formatTime(seconds) {
  const m = Math.floor(seconds / 60);
  const s = seconds % 60;
  return `${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}`;
}
// Initialize
fetchMatches();
updatePage();
// Auto-refresh schedule every 5 minutes
setInterval(fetchMatches, 300000);
</script>
</body>
</html>
