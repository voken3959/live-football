let matches = [];
let currentMatchIndex = 0;
let currentStreamIndex = 0;
let currentPage = 'schedule';
let timerInterval = null;
let streamLoadTimeout = null;
let streamCheckInterval = null;
let isStreamPlaying = false;
const navTabs = document.getElementById('navTabs');
const scheduleGrid = document.getElementById('scheduleGrid');
const streamMatchTitle = document.getElementById('streamMatchTitle');
const streamList = document.getElementById('streamList');
const playerFrame = document.getElementById('playerFrame');
const streamStatus = document.getElementById('streamStatus');
const timerEl = document.getElementById('timer');
const loadingSpinner = document.getElementById('loadingSpinner');

// Page navigation
navTabs.querySelectorAll('.nav-tab').forEach(tab => {
    tab.addEventListener('click', () => {
        currentPage = tab.dataset.page;
        updatePage();
    });
});

function updatePage() {
    document.querySelectorAll('.page').forEach(page => {
        page.classList.toggle('active', page.id === currentPage);
    });
    navTabs.querySelectorAll('.nav-tab').forEach(tab => {
        tab.classList.toggle('active', tab.dataset.page === currentPage);
    });
    if (currentPage === 'schedule') {
        renderSchedule('all');
        clearTimers();
        resetStreamStatus();
    } else if (currentPage === 'streams') {
        renderStreams();
        clearTimers();
        resetStreamStatus();
    } else if (currentPage === 'match') {
        loadStream();
        startMatchTimer();
        startStreamCheck();
    }
}

function clearTimers() {
    if (timerInterval) clearInterval(timerInterval);
    if (streamCheckInterval) clearInterval(streamCheckInterval);
    if (streamLoadTimeout) clearTimeout(streamLoadTimeout);
}

function resetStreamStatus() {
    streamStatus.innerHTML = '<i class="fas fa-exclamation-triangle"></i> Stream may experience interruptions';
    streamStatus.className = 'warning';
    isStreamPlaying = false;
}

// Fetch matches from API
async function fetchMatches() {
    showLoading(true);
    try {
        const response = await fetch('https://streamed.pk/api/matches/football');
        const data = await response.json();
        matches = data
            .filter(m => m.category === 'football' && m.date > 0)
            .map(m => ({
                name: m.title,
                startTime: new Date(m.date),
                sources: m.sources,
                poster: m.poster || 'https://via.placeholder.com/400x200?text=No+Poster',
                teams: m.teams || ['Team A', 'Team B']
            }));
        matches.sort((a, b) => a.startTime - b.startTime);
        renderSchedule('all');
    } catch (error) {
        console.error('Error fetching matches:', error);
        scheduleGrid.innerHTML = '<div style="text-align:center; color:var(--accent-red);">Error loading schedule. Please check your connection or try again later.</div>';
    } finally {
        showLoading(false);
    }
}

// Render schedule
function renderSchedule(filterStatus = 'all', searchQuery = '') {
    scheduleGrid.innerHTML = '';
    const now = new Date();
    const fourHoursInMs = 4 * 60 * 60 * 1000;
    matches.forEach((match, index) => {
        const elapsed = Math.floor((now - match.startTime) / 1000);
        let status = 'finished';
        let timeText = 'Finished';
        if (elapsed < 0) {
            status = 'upcoming';
            timeText = `Starts in ${formatTime(Math.abs(elapsed))}`;
        } else if (elapsed < 120 * 60) {
            status = 'live';
            timeText = `Live for ${formatTime(elapsed)}`;
        }
        const matchEndTime = new Date(match.startTime.getTime() + 110 * 60 * 1000);
        const matchesFilter = filterStatus === 'all' || status === filterStatus;
        const matchesSearch = !searchQuery || match.name.toLowerCase().includes(searchQuery.toLowerCase());
        if (now - matchEndTime <= fourHoursInMs && matchesFilter && matchesSearch) {
            const item = document.createElement('div');
            item.className = `schedule-item ${status}`;
            let teamsHtml = '';
            let teamsText = '';
            if (Array.isArray(match.teams)) {
                teamsText = match.teams.join(' vs ');
            } else if (match.teams.home && match.teams.away) {
                teamsText = `${match.teams.home.name} vs ${match.teams.away.name}`;
                teamsHtml = `
                    <div class="teams-row">
                        <div class="team">
                            <img src="/api/images/proxy/${match.teams.home.badge}.webp" alt="${match.teams.home.name}" class="team-badge">
                            <span>${match.teams.home.name}</span>
                        </div>
                        <span class="vs">vs</span>
                        <div class="team">
                            <img src="/api/images/proxy/${match.teams.away.badge}.webp" alt="${match.teams.away.name}" class="team-badge">
                            <span>${match.teams.away.name}</span>
                        </div>
                    </div>
                `;
            }
            item.innerHTML = `
                <img src="${match.poster}" alt="${match.name} Poster" class="match-poster">
                <div class="match-details">
                    <h3>${match.name}</h3>
                    ${teamsHtml}
                    <p>Teams: ${teamsText}</p>
                    <p>Start: ${match.startTime.toLocaleString()}</p>
                    <p>Status: ${timeText}</p>
                    <span class="match-status ${status}">${status.charAt(0).toUpperCase() + status.slice(1)}</span>
                </div>
            `;
            item.onclick = () => {
                currentMatchIndex = index;
                currentStreamIndex = 0;
                currentPage = 'streams';
                updatePage();
            };
            scheduleGrid.appendChild(item);
        }
    });
    if (scheduleGrid.innerHTML === '') {
        scheduleGrid.innerHTML = '<div style="text-align:center; color:var(--text-medium);">No matches found.</div>';
    }
}

function sortByTime() {
    matches.sort((a, b) => a.startTime - b.startTime);
    renderSchedule('all', document.querySelector('#searchInput')?.value || '');
}

function filterByStatus(status) {
    renderSchedule(status, document.querySelector('#searchInput')?.value || '');
}

function searchMatches() {
    const query = document.getElementById('searchInput').value;
    renderSchedule('all', query);
}

// Render streams
async function renderStreams() {
    const match = matches[currentMatchIndex];
    streamMatchTitle.textContent = match.name;
    streamList.innerHTML = '<div style="text-align:center; color:var(--text-medium);">Loading streams...</div>';
    try {
        const allStreamsArrays = await Promise.all(match.sources.map(async source => {
            try {
                const res = await fetch(`https://streamed.pk/api/stream/${source.source}/${source.id}`);
                const streamData = await res.json();
                return streamData.filter(s => s.embedUrl);
            } catch {
                return [];
            }
        }));
        const allStreams = allStreamsArrays.flat();
        match.streams = allStreams;
        streamList.innerHTML = '';
        if (allStreams.length === 0) {
            streamList.innerHTML = '<div style="text-align:center; color:var(--accent-red);">No streams available for this match.</div>';
            return;
        }
        allStreams.forEach((s, index) => {
            const item = document.createElement('div');
            item.className = 'stream-item';
            item.innerHTML = `
                <i class="fas fa-play-circle"></i> Stream ${index + 1}
                <div class="stream-details">(${s.language}${s.hd ? ' HD' : ''}) - Viewers: ${s.viewers}</div>
            `;
            item.onclick = () => {
                currentStreamIndex = index;
                currentPage = 'match';
                updatePage();
            };
            streamList.appendChild(item);
        });
    } catch (error) {
        console.error('Error fetching streams:', error);
        streamList.innerHTML = '<div style="text-align:center; color:var(--accent-red);">Error loading streams. Please check your internet connection or ensure the page is hosted properly (CORS issue if local).</div>';
    }
}

// Load stream
function loadStream() {
    const match = matches[currentMatchIndex];
    if (!match.streams || currentStreamIndex >= match.streams.length) {
        streamStatus.innerHTML = '<i class="fas fa-times-circle"></i> No more streams available';
        streamStatus.className = 'status-frozen';
        return;
    }
    playerFrame.src = match.streams[currentStreamIndex].embedUrl;
    streamStatus.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Loading stream...';
    streamStatus.className = 'status-loading';
    isStreamPlaying = false;
    clearTimeout(streamLoadTimeout);
    streamLoadTimeout = setTimeout(() => {
        if (!isStreamPlaying) {
            streamStatus.innerHTML = '<i class="fas fa-exclamation-circle"></i> Stream failed to load, trying next...';
            streamStatus.className = 'status-frozen';
            currentStreamIndex = (currentStreamIndex + 1) % match.streams.length;
            loadStream();
        }
    }, 8000); // Increased timeout for better reliability

    playerFrame.onload = () => {
        isStreamPlaying = true;
        streamStatus.innerHTML = '<i class="fas fa-check-circle"></i> Stream active';
        streamStatus.className = 'status-active';
        clearTimeout(streamLoadTimeout);
    };

    playerFrame.onerror = () => {
        isStreamPlaying = false;
        streamStatus.innerHTML = '<i class="fas fa-exclamation-circle"></i> Stream failed to load, trying next...';
        streamStatus.className = 'status-frozen';
        currentStreamIndex = (currentStreamIndex + 1) % match.streams.length;
        loadStream();
    };
}

// Stream check
function startStreamCheck() {
    clearInterval(streamCheckInterval);
    streamCheckInterval = setInterval(() => {
        if (currentPage !== 'match') return;
        if (isStreamPlaying) {
            streamStatus.innerHTML = '<i class="fas fa-check-circle"></i> Stream active';
            streamStatus.className = 'status-active';
        } else {
            streamStatus.innerHTML = '<i class="fas fa-pause-circle"></i> Stream not playing';
            streamStatus.className = 'status-not-playing';
        }
    }, 3000);
}

// Match timer
function startMatchTimer() {
    clearInterval(timerInterval);
    const match = matches[currentMatchIndex];
    const startTime = match.startTime;
    timerInterval = setInterval(() => {
        const currentTime = new Date();
        let elapsed = Math.floor((currentTime - startTime) / 1000);
        let displayText = "";
        if (elapsed < 0) {
            displayText = `<i class="fas fa-hourglass-start"></i> Starts In: ${formatTime(Math.abs(elapsed))}`;
        } else if (elapsed < 45 * 60) {
            displayText = `<i class="fas fa-clock"></i> ${formatTime(elapsed)} (1st Half)`;
        } else if (elapsed < 50 * 60) {
            displayText = `<i class="fas fa-clock"></i> ${formatTime(elapsed - 45 * 60)} (1st Half +)`;
        } else if (elapsed < 60 * 60) {
            displayText = `<i class="fas fa-pause"></i> Halftime: ${formatTime(elapsed - 50 * 60)}`;
        } else if (elapsed < 105 * 60) {
            displayText = `<i class="fas fa-clock"></i> ${formatTime(elapsed - 15 * 60)} (2nd Half)`;
        } else if (elapsed < 110 * 60) {
            displayText = `<i class="fas fa-clock"></i> ${formatTime(elapsed - 105 * 60)} (2nd Half +)`;
        } else {
            displayText = `<i class="fas fa-flag-checkered"></i> Full Time`;
            clearInterval(timerInterval);
        }
        timerEl.innerHTML = displayText;
    }, 1000);
}

function formatTime(seconds) {
    const m = Math.floor(seconds / 60);
    const s = seconds % 60;
    return `${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}`;
}

function toggleFullscreen() {
    const container = document.getElementById('playerContainer');
    if (!document.fullscreenElement) {
        container.requestFullscreen().catch(err => console.error('Fullscreen error:', err));
    } else {
        document.exitFullscreen();
    }
}

function showLoading(show) {
    loadingSpinner.style.display = show ? 'block' : 'none';
}

// Initialize
fetchMatches();
updatePage();
setInterval(fetchMatches, 300000); // Auto-refresh every 5 minutes
